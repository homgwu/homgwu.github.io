<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
      
    
    
      
    
  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
  <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />













<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Kotlin知识点总结与初写时的一些建议">
<meta name="keywords" content="Android,Kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin知识点总结与初写时的一些建议">
<meta property="og:url" content="http://zhuchen.vip/2018/04/01/kotlin/kotlin-learn-summary.html">
<meta property="og:site_name" content="竹尘居士">
<meta property="og:description" content="Kotlin知识点总结与初写时的一些建议">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-04-10T14:16:12.193Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin知识点总结与初写时的一些建议">
<meta name="twitter:description" content="Kotlin知识点总结与初写时的一些建议">






  <link rel="canonical" href="http://zhuchen.vip/2018/04/01/kotlin/kotlin-learn-summary.html"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Kotlin知识点总结与初写时的一些建议 | 竹尘居士</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

<a href="https://github.com/homgwu" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">竹尘居士</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习，分享，成长</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
</li>

      
        
        
          
  
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
</li>

      
        
        
          
  
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  


 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhuchen.vip/2018/04/01/kotlin/kotlin-learn-summary.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HomgWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="竹尘居士">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kotlin知识点总结与初写时的一些建议</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T00:00:00+08:00">2018-04-01</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/04/01/kotlin/kotlin-learn-summary.html" class="leancloud_visitors" data-flag-title="Kotlin知识点总结与初写时的一些建议">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计：</span>
                
                <span title="字数统计">39k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长&asymp;</span>
                
                <span title="阅读时长">0:39</span>
              
            </div>
          

          
              <div class="post-description">Kotlin知识点总结与初写时的一些建议</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文是在学习和使用kotlin时的一些总结与体会，一些代码示例来自于网络或Kotlin官方文档，持续更新…</p>
</blockquote>
<a id="more"></a>
<h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><ul>
<li><p>对象表达式：相当于Java匿名类部类，在使用的地方被立即执行：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listener = <span class="keyword">object</span> : Info(<span class="string">"submit"</span>),IClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"a:<span class="variable">$a</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listener.doClick() <span class="comment">// 打印 a:10</span></span><br><span class="line"><span class="comment">//有时候我们只是需要一个没有父类的对象，我们可以这样写：</span></span><br><span class="line"><span class="keyword">val</span> adHoc = <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(adHoc.x + adHoc.y)</span><br><span class="line"><span class="comment">//像 java 的匿名内部类一样，对象表达式可以访问闭合范围内的变量 (和 java 不一样的是，这些变量不用是 final 修饰的)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="type">JComponent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> enterCount = <span class="number">0</span></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            clickCount++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span>&#123;</span><br><span class="line">            enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象申明：Kotlin 中我们可以方便的通过对象声明来获得一个单例，对象声明是延迟加载的， 在第一次使用的时候被初始化，对象声明不是一个表达式，不能用在赋值语句的右边，对象声明不能在局部作用域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> MyInfo: Info(<span class="string">"submit"</span>),IClickListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"MyInfo do click, <span class="variable">$text</span>"</span>) <span class="comment">// Log: MyInfo do click, , submit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    MyInfo.doClick()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当对象声明在另一个类的内部时，这个类的实例并不能直接访问对象申明内部，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"菜鸟教程"</span></span><br><span class="line">    <span class="keyword">object</span> DeskTop&#123;</span><br><span class="line">        <span class="keyword">var</span> url = <span class="string">"www.runoob.com"</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print&#123;<span class="string">"desk legs <span class="variable">$name</span>"</span>&#125; <span class="comment">// 错误，不能访问到外部类的方法和变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> site = Site()</span><br><span class="line">    site.DeskTop.url <span class="comment">// 错误，不能通过外部类的实例访问到该对象</span></span><br><span class="line">    Site.DeskTop.url <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>伴随(生)对象：相当于静态内部类+该类的静态属性，所在的类被加载，伴生对象被初始化(和 Java 的静态初始是对应)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Books</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">val</span> page: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> ComBooks&#123;</span><br><span class="line">        <span class="keyword">val</span> a : <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doNote</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"do note"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    Books.ComBooks.doNote()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"Book.a = <span class="subst">$&#123;Books.ComBooks.a&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"-------------"</span>)</span><br><span class="line"></span><br><span class="line">    Books.doNote()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Log</span></span><br><span class="line"><span class="keyword">do</span> note</span><br><span class="line">Book.a = <span class="number">10</span></span><br><span class="line">-------------</span><br><span class="line"><span class="keyword">do</span> note</span><br><span class="line"><span class="comment">//伴随对象的成员可以通过类名做限定词直接使用:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> instance = MyClass.create()</span><br><span class="line"><span class="comment">//在使用了 companion 关键字时，伴随对象的名字可以省略：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尽管伴随对象的成员很像其它语言中的静态成员，但在运行时它们任然是真正类的成员实例，比如可以实现接口：</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Factory&lt;MyClass&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果你在 JVM 上使用 @JvmStatic 注解，你可以有多个伴随对象生成为真实的静态方法和属性</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性字段相关"><a href="#属性字段相关" class="headerlink" title="属性字段相关"></a>属性字段相关</h2><ul>
<li><p>备用字段：Kotlin中不能有field，但在自定义getter/setter的时候需要直接访问属性而不是又通过getter/settter来取值赋值(循环调用)。Kotlin自动提供一个备用字段(field)，通过它可以直接访问属性，没有使用备用字段时不生成备用字段(使用了setter就会生成)，:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用field关键字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> fieldProp = <span class="string">""</span></span><br><span class="line">    <span class="keyword">get</span>() = field</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        field = value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//不生成：</span></span><br><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br><span class="line"><span class="comment">//生成：</span></span><br><span class="line"><span class="keyword">val</span> Foo.bar = <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>备用属性：功能与备用字段类似。：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_table == <span class="literal">null</span>) &#123;</span><br><span class="line">            _table = HashMap() <span class="comment">// 参数类型是自动推导</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">"Set to null by another thread"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin可以像python(@property)一样把方法变成属性调用，Kotlin是定义一个属性复写get()方法返回某个对象中其他的计算出来的值。</p>
</li>
</ul>
<h2 id="编译时常量"><a href="#编译时常量" class="headerlink" title="编译时常量"></a>编译时常量</h2><ul>
<li><p>相当于java static finial xxx，而val 只是fInal ，一个编译时常量，一个运行时常量。使用const必须：</p>
<ul>
<li>在kt文件中(类之外，Top-level)或在object{}中</li>
<li>必须是基本类型或String</li>
<li>必须没有自定义getter</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">val</span> SUBSYSTEM_DEPRECATED: String = <span class="string">"This subsystem is deprecated"</span></span><br><span class="line"><span class="meta">@Deprected(SUBSYSTEM_DEPRECATED)</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="延迟初始化属性"><a href="#延迟初始化属性" class="headerlink" title="延迟初始化属性"></a>延迟初始化属性</h2><ul>
<li><p>当定义属性时没有使用 ? ，那么说明是一个非空属性，这时必须要初始化，如果想在后面的方法中再去赋值要加上lateinit。：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: TestSubject</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SetUp</span> <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject = TestSubject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.method()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个修饰符只能够被用在类的 var 类型的可变属性定义中,不能用在构造方法中.并且属性不能有自定义的 getter 和 setter访问器.这个属性的类型必须是非空的,同样也不能为一个基本类型.在一个lateinit的属性初始化前访问他,会导致一个特定异常,告诉你访问的时候值还没有初始化</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="复写属性"><a href="#复写属性" class="headerlink" title="复写属性"></a>复写属性</h2><ul>
<li>属性可复写，在主构造函数中就可使用override关键字作为属性声明。</li>
</ul>
<h2 id="代理-委托-模式"><a href="#代理-委托-模式" class="headerlink" title="代理(委托)模式"></a>代理(委托)模式</h2><ul>
<li><p>类代理：<br>Kotlin 在语法上支持代理 ，Derived 类可以继承 Base 接口并且指定一个对象代理它全部的公共方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; printz(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在 Derived 的父类列表中的 by 从句会将 b 存储在 Derived 内部对象，并且编译器会生成 Base 的所有方法并转给 b</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>代理属性：<br>所谓的委托属性，就是对其属性值的操作不再依赖于其自身的getter()/setter()方法，是将其托付给一个代理类，从而每个使用类中的该属性可以通过代理类统一管理，再也不用在每个类中，对其声明重复的操作方法。语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> &lt;property name&gt;: &lt;Type&gt; <span class="keyword">by</span> &lt;expression&gt;</span><br><span class="line"><span class="comment">//var/val：属性类型(可变/只读)</span></span><br><span class="line"><span class="comment">//name：属性名称</span></span><br><span class="line"><span class="comment">//Type：属性的数据类型</span></span><br><span class="line"><span class="comment">//expression：代理类</span></span><br></pre></td></tr></table></figure>
<p>使用场景:</p>
<ul>
<li>延迟加载属性(lazy property): 属性值只在初次访问时才会计算</li>
<li>可观察属性(observable property): 属性发生变化时, 可以向监听器发送通知</li>
<li>将多个属性保存在一个 map 内, 而不是保存在多个独立的域内</li>
</ul>
<p>Kotlin标准库中已实现的代理：</p>
<ul>
<li><p>延迟加载(Lazy)：lazy()是一个函数, 接受一个Lambda表达式作为参数, 返回一个Lazy类型的实例,这个实例可以作为一个委托, 实现延迟加载属性(lazy property): 第一次调用 get() 时, 将会执行 lazy() 函数受到的Lambda 表达式,然后会记住这次执行的结果, 以后所有对 get() 的调用都只会简单地返回以前记住的结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> no: <span class="built_in">Int</span> <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    println(no) <span class="comment">// Log : 200</span></span><br><span class="line">    println(no) <span class="comment">// Log : 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>var类型属性不能设置为延迟加载属性，因为在lazy中并没有setValue(…)方法</li>
<li>lazy操作符是线程安全的。如果在不考虑多线程问题或者想提高更多的性能，也可以使用 lazy(LazyThreadSafeMode.NONE){ … }，lazy的三个参数为：<ul>
<li>SYNCHRONIZED：锁定，用于确保只有一个线程可以初始化[Lazy]实例。</li>
<li>PUBLICATION：初始化函数可以在并发访问未初始化的[Lazy]实例值时调用几次，，但只有第一个返回的值将被用作[Lazy]实例的值。</li>
<li>NONE：没有锁用于同步对[Lazy]实例值的访问; 如果从多个线程访问实例，是线程不安全的。此模式应仅在高性能至关重要，并且[Lazy]实例被保证永远不会从多个线程初始化时使用。</li>
</ul>
</li>
</ul>
</li>
<li><p>可观察属性(Observable)：Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler).这种形式的委托，采用了观察者模式，其会检测可观察属性的变化，当被观察属性的setter()方法被调用的时候，响应器(handler)都会被调用(在属性赋值处理完成之后)并自动执行执行的lambda表达式，同时响应器会收到三个参数：被赋值的属性, 赋值前的旧属性值, 以及赋值后的新属性值。：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"wang"</span>, &#123;</span><br><span class="line">    kProperty, oldName, newName -&gt;</span><br><span class="line">    println(<span class="string">"kProperty：<span class="subst">$&#123;kProperty.name&#125;</span> | oldName:<span class="variable">$oldName</span> | newName:<span class="variable">$newName</span>"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"name: <span class="variable">$name</span>"</span>) <span class="comment">// Log：nam：wang</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">"zhang"</span> <span class="comment">// Log：kProperty：name | oldName:wang | newName:zhang</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">"li"</span> <span class="comment">// Log：kProperty：name | oldName:zhang | newName:li</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Delegates.observable(wang, hanler),完成了两项工作，一是，将name初始化(name=wang)；二是检测name属性值的变化，每次变化时，都会打印其赋值前的旧属性值, 以及赋值后的新属性值。</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Vetoable：Delegates.vetoable()函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler),是可观察属性(Observable)的一个特例，不同的是在响应器指定的自动执行执行的lambda表达式中在保存新值之前做一些条件判断，来决定是否将新值保存。：</span><br><span class="line"></span><br><span class="line">  ```kotlin</span><br><span class="line">  var name: String by Delegates.vetoable(&quot;wang&quot;, &#123;</span><br><span class="line">      kProperty, oldValue, newValue -&gt;</span><br><span class="line">      println(&quot;oldValue：$oldValue | newValue：$newValue&quot;)</span><br><span class="line">      newValue.contains(&quot;wang&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">      println(&quot;name: $name&quot;)</span><br><span class="line">      println(&quot;------------------&quot;)</span><br><span class="line">      name = &quot;zhangLing&quot; </span><br><span class="line">      println(&quot;name: $name&quot;) </span><br><span class="line">      println(&quot;------------------&quot;)</span><br><span class="line">      name = &quot;wangBing&quot; </span><br><span class="line">      println(&quot;name: $name&quot;) </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //Log </span><br><span class="line">  name: wang</span><br><span class="line">  ------------------</span><br><span class="line">  oldValue：wang | newValue：zhangLing</span><br><span class="line">  name: wang</span><br><span class="line">  ------------------</span><br><span class="line">  oldValue：wang | newValue：wangBing</span><br><span class="line">  name: wangBing</span><br><span class="line">  ​</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Not Null：在实际开发时，我们可能会设置可为null的var类型属性，在我们使用它时，肯定是对其赋值，假如不赋值，必然要报NullPointException.一种解决方案是，我们可以在使用它时，在每个地方不管是不是null，都做null检查，这样我们就保证了在使用它时，保证它不是null。这样无形当中添加了很多重复的代码。在Kotlin中，用委托可以不用去写这些重复的代码，Not Null委托会含有一个可null的变量并会在我们设置这个属性的时候分配一个真实的值。如果这个值在被获取之前没有被分配，它就会抛出一个异常。</span><br><span class="line"></span><br><span class="line">  ```kotlin</span><br><span class="line">  class App : Application() &#123;</span><br><span class="line">      companion object &#123;</span><br><span class="line">          var instance: App by Delegates.notNull()</span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      override fun onCreate() &#123;</span><br><span class="line">          super.onCreate()</span><br><span class="line">          instance = this</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将多个属性保存在一个map内：使用Gson解析Json时，可以获取到相应的实体类的实例，当然该实体类的属性名称与Json中的key是一一对应的。在Kotlin中，存在这么一种委托方式，类的构造器接受一个map实例作为参数，将map实例本身作为属性的委托，属性的名称与map中的key是一致的，也就是意味着我们可以很简单的从一个动态地map中创建一个对象实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = User(mapOf(</span><br><span class="line">            <span class="string">"name"</span> to <span class="string">"John Doe"</span>,</span><br><span class="line">            <span class="string">"age"</span> to <span class="number">25</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    println(user.name) <span class="comment">// 打印结果为: "John Doe"</span></span><br><span class="line">    println(user.age) <span class="comment">// 打印结果为: 25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//委托属性将从这个 map中读取属性值(使用属性名称字符串作为 key 值)。</span></span><br><span class="line"><span class="comment">//如果不用只读的 Map , 而改用值可变的 MutableMap , 那么也可以用作 var 属性的委托。：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: MutableMap&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map:MutableMap&lt;String, Any?&gt; = mutableMapOf(</span><br><span class="line">            <span class="string">"name"</span> to <span class="string">"John Doe"</span>,</span><br><span class="line">            <span class="string">"age"</span> to <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = User(map)</span><br><span class="line"></span><br><span class="line">    println(user.name) <span class="comment">// 打印结果为: "John Doe"</span></span><br><span class="line">    println(user.age) <span class="comment">// 打印结果为: 25</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">"--------------"</span>)</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"Green Dao"</span>)</span><br><span class="line">    map.put(<span class="string">"age"</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    println(user.name) <span class="comment">// 打印结果为: Green Dao</span></span><br><span class="line">    println(user.age) <span class="comment">// 打印结果为: 30</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性委托的前提条件：getValue()，setValue()。自定义委托必须要实现：ReadOnlyProperty和ReadWriteProperty。取决于我们被委托的对象是val还是var，如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteProperty</span>&lt;<span class="type">in R, T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个NotNullVar</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NotNullVar</span>&lt;<span class="type">T: Any</span>&gt;</span>() : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"Property <span class="subst">$&#123;property.name&#125;</span> should be initialized before get."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个thisRef表示持有该对象的对象,</span></span><br><span class="line"><span class="comment">//第二个参数 property 是该值的类型,</span></span><br><span class="line"><span class="comment">//第三个参数 value 就是属性的值了</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><ul>
<li><p>密封类：类的扩展,但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例，虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明，间接的子类不受限制。密封类是自身抽象的，它不能直接实例化并可以有抽象（abstract）成员。密封类不允许有非-private 构造函数（其构造函数默认为 private）。使用密封类的关键好处在于使用 when 表达式 的时候，能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">    <span class="comment">// 不再需要 `else` 子句，因为我们已经覆盖了所有的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>与java8类似可有抽象方法与实现方法，不可保存状态，属性必须是抽象的或唯一值的(无备用属性)。</p>
<p>​</p>
</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li><p>不需要在类中去添加方法，在外部就可以给任何地方的类添加我们想要的方法，替换掉java中的FileUtil,xxxUtil等如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.swap(list, Collections.binarySearch(list, Collections.max(otherList)), Collections.max(list))</span><br><span class="line"><span class="comment">//变成</span></span><br><span class="line">list.swap(list.binarySearch(otherList.max()), list.max())</span><br></pre></td></tr></table></figure>
<p>扩展是被静态解析的:扩展实际上并没有修改它所扩展的类,只是让这个类的实例对象能够通过”.”调用新的函数。需要强调的是扩展函数是静态分发的，举个例子,它们并不是接受者类型的虚拟方法。这意味着扩展函数的调用是由发起函数调用的表达式的(对象)类型决定的，而不是在运行时动态获得的表达式的(对象)类型决定。比如:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123; </span><br><span class="line">    println(c.foo())</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">printFoo(D())</span><br><span class="line"><span class="comment">//输出 c，因为这里扩展函数的调用决定于声明的参数 c 的类型，也就是 C。</span></span><br></pre></td></tr></table></figure>
<p>如果有同名同参数的成员函数和扩展函数，调用的时候会使用成员函数，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"member"</span>) &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"extension"</span>) &#125;</span><br><span class="line">C().foo()</span><br><span class="line"><span class="comment">//输出"member",而不是"extension"</span></span><br><span class="line"><span class="comment">//可以通过不同的函数签名的方式重载函数的成员函数：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">(i:<span class="type">Int</span>)</span></span> &#123; println(<span class="string">"extention"</span>) &#125;</span><br><span class="line">C().foo(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//输出 “extentions”。</span></span><br></pre></td></tr></table></figure>
<p>扩展的域：大多数时候我们在 top level 定义扩展(就在包下面直接定义)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Baz.<span class="title">goo</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"><span class="comment">//为了在除声明的包外使用这个扩展，我们需要在别的文件中使用时导入：</span></span><br><span class="line"><span class="comment">//-------------------------------------------------//</span></span><br><span class="line"><span class="keyword">package</span> com.example.usage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo.bar.goo <span class="comment">// 导入所有名字叫 "goo" 的扩展</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo.bar.* <span class="comment">// 导入foo.bar包下得所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">usage</span><span class="params">(baz: <span class="type">Baz</span>)</span></span> &#123;</span><br><span class="line">    baz.goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>函数扩展：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">swap</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> tmp = <span class="keyword">this</span>[x] <span class="comment">// 'this' corresponds to the list</span></span><br><span class="line">  <span class="keyword">this</span>[x] = <span class="keyword">this</span>[y]</span><br><span class="line">  <span class="keyword">this</span>[y] = tmp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//this 关键字对应接收者对象(MutableList&lt;T&gt;)</span></span><br><span class="line"><span class="comment">//使用:</span></span><br><span class="line"><span class="keyword">val</span> l = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">l.swap(<span class="number">0</span>, <span class="number">2</span>)<span class="comment">// 在 `swap()` 函数中 `this` 持有的值是 `l`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可空的接收者：<br>使用空接收者类型进行定义。这样的扩展使得，即使是一个空对象仍然可以调用该扩展，然后在扩展的内部进行 this == null 的判断。这样你就可以在 Kotlin 中任意调用 toString() 方法而不进行空指针检查：空指针检查延后到扩展函数中完成:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    <span class="comment">// 在空检查之后，`this` 被自动转为非空类型，因此 toString() 可以被解析到任何类的成员函数中</span></span><br><span class="line">    <span class="keyword">return</span> toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T.所以扩展是用.来使用的，如Kotlin的to函数就是A to B 以空格使用。</p>
</li>
<li><h3 id="属性扩展"><a href="#属性扩展" class="headerlink" title="属性扩展"></a>属性扩展</h3><p>注意，由于扩展并不会真正给类添加了成员属性，因此也没有办法让扩展属性拥有一个备份字段.这也是为什么初始化函数不允许有扩展属性。扩展属性只能够通过明确提供 getter 和 setter方法来进行定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确：</span></span><br><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex:  <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = size<span class="number">-1</span></span><br><span class="line"><span class="comment">//错误：</span></span><br><span class="line"><span class="keyword">val</span> Foo.bar = <span class="number">1</span> <span class="comment">//error: initializers are not allowed for extension properties</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><h3 id="伴随对象扩展"><a href="#伴随对象扩展" class="headerlink" title="伴随对象扩展"></a>伴随对象扩展</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">MyClass.foo()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>   我们经常创建一个只保存数据的类。在这样的类中一些函数只是机械的对它们持有的数据进行，如从服务端返回的Json字符串对象映射成Java类。data类使用：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> 类名</span>(<span class="keyword">var</span> param1 ：数据类型,...)&#123;&#125;</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> 类名 可见性修饰符 <span class="keyword">constructor</span></span>(<span class="keyword">var</span> param1 : 数据类型 = 默认值,...)</span><br><span class="line"><span class="comment">//data为声明数据类的关键字，必须书写在class关键字之前。</span></span><br><span class="line"><span class="comment">//在没有结构体的时候，大括号&#123;&#125;可省略。</span></span><br><span class="line"><span class="comment">//构造函数中必须存在至少一个参数，并且必须使用val或var修饰。这一点在下面数据类特性中会详细讲解。</span></span><br><span class="line"><span class="comment">//参数的默认值可有可无。（若要实例一个无参数的数据类，则就要用到默认值）</span></span><br><span class="line"><span class="comment">// 定义一个名为Person的数据类:</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Preson</span></span>(<span class="keyword">var</span> name : String,<span class="keyword">val</span> sex : <span class="built_in">Int</span>, <span class="keyword">var</span> age : <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<p>  data类必须满足的条件：</p>
<ul>
<li>主构造函数需要至少有一个参数</li>
<li>主构造函数的所有参数需要标记为 val 或 var；</li>
<li>数据类不能是抽象、开放、密封或者内部的；</li>
<li><p>数据类是可以实现接口的，如(序列化接口)，同时也是可以继承其他类的，如继承自一个密封类。</p>
<p>约定俗成的规定:当构造函数中的参过多时，为了代码的阅读性，一个参数的定义占据一行。</p>
<p>编辑器为我们做的事情：</p>
</li>
<li><p>生成equals()函数与hasCode()函数</p>
</li>
<li>生成toString()函数，由类名（参数1 = 值1，参数2 = 值2，….）构成</li>
<li>由所定义的属性自动生成component1()、component2()、…、componentN()函数，其对应于属性的声明顺序。</li>
<li><p>copy()函数。修改部分属性，但是保持其他不变。</p>
<p>copy函数的使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name : String, <span class="keyword">val</span> pwd : String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mUser = User(<span class="string">"kotlin"</span>,<span class="string">"123456"</span>)</span><br><span class="line">println(mUser)</span><br><span class="line"><span class="keyword">val</span> mNewUser = mUser.copy(name = <span class="string">"new Kotlin"</span>)</span><br><span class="line">println(mNewUser)</span><br></pre></td></tr></table></figure>
<p>标准库提供的data类： Pair 和 Triple，源码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@file:kotlin</span>.jvm.JvmName(<span class="string">"TuplesKt"</span>)</span><br><span class="line"><span class="keyword">package</span> kotlin</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里去掉了源码中的注释</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="type">out A, out B</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> first: A,</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> second: B) : Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// toString()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">"(<span class="variable">$first</span>, <span class="variable">$second</span>)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt; = Pair(<span class="keyword">this</span>, that)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成List集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Pair<span class="type">&lt;T, T&gt;</span>.<span class="title">toList</span><span class="params">()</span></span>: List&lt;T&gt; = listOf(first, second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里去掉了源码中的注释</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Triple</span>&lt;<span class="type">out A, out B, out C</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> first: A,</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> second: B,</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> third: C ) : Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">"(<span class="variable">$first</span>, <span class="variable">$second</span>, <span class="variable">$third</span>)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成List集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Triple<span class="type">&lt;T, T, T&gt;</span>.<span class="title">toList</span><span class="params">()</span></span>: List&lt;T&gt; = listOf(first, second, third)</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li><p>两种型变：</p>
<ul>
<li><p>协变：当A ≦ B时,如果有f(A) ≦ f(B),那么f叫做协变；</p>
</li>
<li><p>逆变：当A ≦ B时,如果有f(B) ≦ f(A),那么f叫做逆变；</p>
<p>其余为不变。</p>
</li>
</ul>
<p>协变，逆变，不变来原于子类可以安全的向上转型为父类。</p>
</li>
<li><p>不变(java的泛型<t>是不变的)：</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//type mismatch</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>协变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list001 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">List&lt;? extends Number&gt; list002 = <span class="keyword">new</span> ArrayList&lt;Float&gt;(); </span><br><span class="line">Number n1=list001.get(<span class="number">0</span>);</span><br><span class="line">Number n2=list002.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>​    “? extends Number”则表示通配符”?”的上界为Number，换句话说就是，“? extends Number”可以代表Number或其子类，但代表不了Number的父类（如Object），因为通配符的上界是Number。于是有“? extends Number” ≦ Number，则List&lt;? extends Number&gt; ≦ List&lt; Number &gt;。但是这里不能向list001、list002添加除null以外的任意对象。可以这样理解一下，List<integer>可以添加Interger及其子类，List<float>可以添加Float及其子类，List<integer>、List<float>都是List&lt;? extends Animal&gt;的子类型，如果能将Float的子类添加到List&lt;? extends Animal&gt;中，就说明Float的子类也是可以添加到List<integer>中的，显然是不可行。故java为了保护其类型一致，禁止向List&lt;? extends Number&gt;添加任意对象，不过却可以添加null。</integer></float></integer></float></integer></p>
</li>
<li><p>逆变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list001 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();  </span><br><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list002 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();  </span><br><span class="line">list001.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));  </span><br><span class="line">list002.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p> “? super Number” 则表示通配符”?”的下界为Number。为了保护类型的一致性，因为“？ super Number”可以是Object或其他Number的父类，因无法确定其类型，也就不能往List&lt;? super Number &gt;添加Number的任意父类对象。但是可以向List&lt;? super Number &gt;添加Number及其子类。</p>
</li>
<li><p>PECS(《Effective Java》，producer-extends, consumer-super)：协变只能取(生产者)，逆变只能写(消费者)，如java的几个api：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span>:  </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//push all</span></span><br><span class="line"><span class="comment">// Wildcard type for parameter that serves as an E producer  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (E e : src)  </span><br><span class="line">        push(e);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//pop all</span></span><br><span class="line"><span class="comment">// Wildcard type for parameter that serves as an E consumer  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (!isEmpty())  </span><br><span class="line">        dst.add(pop());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// java.util.Collections的copy方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> srcSize = src.size();  </span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Source does not fit in dest"</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||  </span><br><span class="line">        (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)  </span><br><span class="line">            dest.set(i, src.get(i));  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ListIterator&lt;? <span class="keyword">super</span> T&gt; di=dest.listIterator();  </span><br><span class="line">        ListIterator&lt;? extends T&gt; si=src.listIterator();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;  </span><br><span class="line">            di.next();  </span><br><span class="line">            di.set(si.next());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Kotlin 用out ，in修饰符使协变与逆变使用起来更方便,out表示只生成，in表示只消费，称之为声明处变型。这与 Java 中的使用处变型相反：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(strs: <span class="type">Source</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> objects: Source&lt;Any&gt; = strs <span class="comment">// This is OK, since T is an out-parameter</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------//</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Comparable</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Comparable</span>&lt;<span class="type">Number</span>&gt;)</span></span> &#123;</span><br><span class="line">    x.compareTo(<span class="number">1.0</span>) <span class="comment">// 1.0 has type Double, which is a subtype of Number</span></span><br><span class="line">    <span class="comment">// Thus, we can assign x to a variable of type Comparable&lt;Double&gt;</span></span><br><span class="line">    <span class="keyword">val</span> y: Comparable&lt;<span class="built_in">Double</span>&gt; = x <span class="comment">// OK!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型投影</p>
<p>使用处变型：类型投影。有些类 不能 限制它只返回 T，如Array，T既要返回又要在参数中消费：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> size: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个类既不能是协变的也不能是逆变的，这会在一定程度上降低灵活性。考虑下面的函数形式：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>星投影</p>
<p>有时你对类型参数一无所知，但任然想安全的使用它。保险的方法就是定一个该范型的投影，每个该范型的正确实例都将是该投影的子类，Foo&lt;*&gt;</p>
</li>
<li><p>范型约束</p>
<p>上界：最常用的类型约束是上界，在 Java 中对应 extends关键字，这里的上界只是约束在给泛型定型时要满足的条件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">sort(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// OK. Int is a subtype of Comparable&lt;Int&gt;</span></span><br><span class="line">sort(listOf(HashMap&lt;<span class="built_in">Int</span>, String&gt;())) <span class="comment">// Error: HashMap&lt;Int, String&gt; is not a subtype of Comparable&lt;HashMap&lt;Int, String&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认的上界是 Any?。在尖括号内只能指定一个上界。如果要指定多种上界，需要用 where 语句指定:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cloneWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;T&gt;</span><br><span class="line">    where T : Comparable,</span><br><span class="line">          T : Cloneable &#123;</span><br><span class="line">  <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.clone() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><ul>
<li><p>嵌套类，与java的静态内部类相似：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> demo = Outer.Nested().foo() <span class="comment">//==2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类，相当与java的内部类，持有一个外部类的引用，不能单独使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> demo = Outer().Inner().foo() <span class="comment">//==1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名内部类，通过对象表达式创建：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span>: MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//如果对象是函数式的 java 接口的实例（比如只有一个抽象方法的 java 接口），你可以用一个带接口类型的 lambda 表达式创建它</span></span><br><span class="line"><span class="keyword">val</span> listener = ActionListener &#123; println(<span class="string">"clicked"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>函数参数</p>
<ul>
<li><p>标准参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">powerOf</span><span class="params">(number: <span class="type">Int</span>, exponent: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认参数,函数参数可以设置默认值,当调用函数时参数被忽略会使用默认值。这样相比其他语言可以减少重载：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, off: <span class="type">Int</span> = <span class="number">0</span>, len: <span class="type">Int</span> = b.size )</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名参数：在调用函数时可以用参数的命名来赋值参数。这对于那种有大量参数的函数很方便：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reformat</span><span class="params">(str: <span class="type">String</span>, normalizeCase: <span class="type">Boolean</span> = <span class="literal">true</span>,upperCaseFirstLetter: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             divideByCamelHumps: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             wordSeparator: <span class="type">Char</span> = <span class="string">' '</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用：</span></span><br><span class="line"><span class="comment">//使用默认参数:</span></span><br><span class="line">reformat(str)</span><br><span class="line"><span class="comment">//调用非默认参数:</span></span><br><span class="line">reformat(str, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">'_'</span>)</span><br><span class="line"><span class="comment">//使用命名参数:</span></span><br><span class="line">reformat(str,</span><br><span class="line">    normalizeCase = <span class="literal">true</span>,</span><br><span class="line">    uppercaseFirstLetter = <span class="literal">true</span>,</span><br><span class="line">    divideByCamelHumps = <span class="literal">false</span>,</span><br><span class="line">    wordSeparator = <span class="string">'_'</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">//不需要全部参数:</span></span><br><span class="line">reformat(str, wordSeparator = <span class="string">'_'</span>)</span><br><span class="line"><span class="comment">//注意,命名参数语法不能够被用于调用Java函数中,因为Java的字节码不能确保方法参数命名的不变性</span></span><br></pre></td></tr></table></figure>
<p>默认参数可能只是给参数一个默认值，而命名参数则给参数一个有意义的名字。</p>
</li>
<li><p>不带返回值的参数:</p>
<p>如果函数不会返回任何有用值，那么他的返回类型就是 Unit .Unit 是一个只有唯一值Unit的类型.这个值并不需要被直接返回:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHello</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>)</span><br><span class="line">        println(<span class="string">"Hello <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        println(<span class="string">"Hi there!"</span>)</span><br><span class="line">    <span class="comment">// `return Unit` or `return` is optional</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Unit 返回值也可以省略:</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHello</span><span class="params">(name: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变长参数:</p>
<p>函数的参数(通常是最后一个参数)可以用 vararg 修饰符进行标记:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">asList</span><span class="params">(<span class="keyword">vararg</span> ts: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (t <span class="keyword">in</span> ts)</span><br><span class="line">        result.add(t)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标记后,允许给函数传递可变长度的参数：</span></span><br><span class="line"><span class="keyword">val</span> list = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//只有一个参数可以被标注为 vararg 。加入vararg并不是列表中的最后一个参数,那么后面的参数需要通过命名参数语法进行传值,再或者如果这个参数是函数类型,就需要通过lambda法则.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当调用变长参数的函数时，我们可以一个一个的传递参数，比如 asList(1, 2, 3)，或者我们要传递一个 array 的内容给函数，我们就可以使用 * 前缀操作符：</span></span><br><span class="line"><span class="keyword">val</span> a = array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> list = asList(<span class="number">-1</span>, <span class="number">0</span>, *a, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>各种类型参数定义与使用与Python相似</p>
</li>
</ul>
</li>
<li><p>单表达式函数:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当函数只返回单个表达式时，大括号可以省略并在 = 后面定义函数体:</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x*<span class="number">2</span></span><br><span class="line"><span class="comment">//在编译器可以推断出返回值类型的时候,返回值的类型可以省略:</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>函数范围</p>
<p>Kotlin 中可以在文件顶级声明函数，这就意味者你不用像在Java,C#或是Scala一样创建一个类来持有函数。除了顶级函数，Kotlin 函数可以声明为局部的，作为成员函数或扩展函数:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(graph: <span class="type">Graph</span>)</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>, visited: <span class="type">Set</span>&lt;<span class="type">Vertex</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</span><br><span class="line">      dfs(v, visited)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(graph.vertices[<span class="number">0</span>], HashSet())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//局部函数可以访问外部函数的局部变量(比如闭包)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(graph: <span class="type">Graph</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> visited = HashSet&lt;Vertex&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</span><br><span class="line">            dfs(v)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(graph.vertices[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//局部函数甚至可以返回到外部函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reachable</span><span class="params">(from: <span class="type">Vertex</span>, to: <span class="type">Vertex</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> visited = HashSet&lt;Vertex&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == to) <span class="keyword">return</span><span class="symbol">@reachable</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (v  <span class="keyword">in</span> current.neighbors)</span><br><span class="line">            dfs(v)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(from)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员函数</p>
<p>跟java一样，类中的成员。</p>
</li>
<li><p>泛型函数</p>
<p>跟java一样。</p>
</li>
<li><p>尾递归函数</p>
<p>Kotlin 支持函数式编程的尾递归。这个允许一些算法可以通过循环而不是递归解决问题，从而避免了栈溢出。当函数被标记为 tailrec 时，编译器会优化递归，并用高效迅速的循环代替它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tailrec <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">(x: <span class="type">Double</span> = <span class="number">1.0</span>)</span></span>: <span class="built_in">Double</span> </span><br><span class="line">    = <span class="keyword">if</span> (x == Math.cos(x)) x <span class="keyword">else</span> findFixPoint(Math.cos(x))</span><br><span class="line"><span class="comment">//使用 tailrec 修饰符必须在最后一个操作中调用自己。在递归调用代码后面是不允许有其它代码的，并且也不可以在 try/catch/finall 块中进行使用。当前的尾递归只在 JVM 的后端中可以用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>高阶函数</p>
<p>高阶函数就是可以接受函数作为参数或者返回一个函数的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lock</span><span class="params">(lock: <span class="type">Lock</span>, body: ()</span></span> -&gt; T ) : T &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//body 是一个类型为 () -&gt; T 的函数，可以这样使用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toBeSynchroized</span><span class="params">()</span></span> = sharedResource.operation()</span><br><span class="line"><span class="keyword">val</span> result = lock(lock, ::toBeSynchroized)</span><br><span class="line"><span class="comment">//更方便的是传一个字面函数(lambda表达式)</span></span><br><span class="line"><span class="keyword">val</span> result = lock(lock, &#123;</span><br><span class="line">sharedResource.operation() &#125;)</span><br><span class="line"><span class="comment">//在 kotlin 中有一个约定，如果某一个函数的最后一个参数是函数，并且你向那个位置传递了一个 lambda 表达式，那么，你可以在括号外面定义这个 lambda 表达式:</span></span><br><span class="line">lock (lock) &#123;</span><br><span class="line">    sharedResource.operation()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//高阶函数map:</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">T</span>)</span></span> -&gt; R):</span><br><span class="line">List&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = arrayListOf&lt;R&gt;()</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">        result.add(transform(item))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用:</span></span><br><span class="line"><span class="keyword">val</span> doubled = ints.map &#123;it -&gt; it * <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//如果字面函数只有一个参数，则声明可以省略，名字就是 it :</span></span><br><span class="line">ints.map &#123;it * <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//这样就可以写LINQ-风格的代码了：</span></span><br><span class="line">strings.filter&#123; it.length == <span class="number">5</span> &#125;.sortedBy&#123; it &#125;.map&#123; it.toUpperCase() &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字面函数和函数表达式(lambda表达式),字面函数或函数表达式就是一个 “匿名函数”，也就是没有声明的函数，但立即作为表达式传递下去:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(strings, &#123;a, b -&gt; a.length &lt; b.length &#125;)</span><br><span class="line"><span class="comment">//max 函数就是一个高阶函数,它接受函数作为第二个参数。第二个参数是一个表达式所以本生就是一个函数，即字面函数。作为一个函数，相当于:</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">String</span>)</span></span> : <span class="built_in">Boolean</span> = a.length &lt; b.length</span><br></pre></td></tr></table></figure>
<p>如果只有一个参数lambda中可以不写参数变量，直接用it表示参数，如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;it.length&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Lambda表达式接收器：</p>
<p>(函数字面量接收器,在定义高阶函数参数时使用）是上面两者的结合——一个以指定接收器的扩展函数为参数的高阶函数。所以在我们传递的Lambda表达式中我们可以直接访问接收器的公共方法和属性(在接受器的上下文环境中)，就好像在接收器内部一样:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> FragmentManager.<span class="title">inTransaction</span><span class="params">(func: <span class="type">FragmentTransaction</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> fragmentTransaction = beginTransaction()</span><br><span class="line">    fragmentTransaction.func()</span><br><span class="line">    fragmentTransaction.commit()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或：</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> FragmentManager.<span class="title">inTransaction</span><span class="params">(func: <span class="type">FragmentTransaction</span>.()</span></span> -&gt; FragmentTransaction) &#123;</span><br><span class="line">    beginTransaction().func().commit()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这就是FragmentManager的扩展函数,接收一个Lambda表达式接收器作为参数,FragmentTransaction作为接收器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">supportFragmentManager.inTransaction &#123;</span><br><span class="line">    <span class="comment">//remove(fragmentA)    </span></span><br><span class="line">    add(R.id.frameLayoutContent, fragmentB)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要说明的是在Lambda表达式中我们调用FragmentTransaction的方法如add或者remove时并没有使用修饰符,因为这是对FragmentTransaction的扩展函数.</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>函数类型</p>
<p>一个函数要接受另一个函数作为参数，我们得给它指定一个类型。比如上面的 max：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> max<span class="type">&lt;T&gt;</span><span class="params">(collection: <span class="type">Collection</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, less: (<span class="type">T</span>, T)</span></span> -&gt; <span class="built_in">Boolean</span>): T? &#123;</span><br><span class="line">    <span class="keyword">var</span> max: T? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (it <span class="keyword">in</span> collection)</span><br><span class="line">        <span class="keyword">if</span> (max == <span class="literal">null</span> || less(max!!, it))</span><br><span class="line">            max = it</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数 less 是 (T, T) -&gt; Boolean类型，也就是接受俩个 T 类型参数返回一个 Boolean:如果第一个参数小于第二个则返回真。在函数体第四行， less 是用作函数。</span></span><br><span class="line"><span class="comment">//一个函数类型可以像上面那样写，也可有命名参数</span></span><br><span class="line"><span class="keyword">val</span> compare: (x: T,y: T) -&gt; <span class="built_in">Int</span> = ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数文本语法</p>
<p>函数文本的完全写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123;x: <span class="built_in">Int</span>,y: <span class="built_in">Int</span> -&gt; x + y&#125;</span><br><span class="line"><span class="comment">//函数文本总是在大括号里包裹着，在完全语法中参数声明是在括号内，类型注解是可选的，函数体是在　-&gt; 之后，像下面这样:</span></span><br><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;x, y -&gt; x+y &#125;</span><br><span class="line"><span class="comment">//函数文本有时只有一个参数。如果 kotlin 可以从它本生计算出签名，那么可以省略这个唯一的参数，并会通过 it 隐式的声明它</span></span><br><span class="line">ints.filter &#123;it &gt; <span class="number">0</span>&#125;<span class="comment">//这是 (it: Int) -&gt; Boolean  的字面意思</span></span><br><span class="line"><span class="comment">//注意如果一个函数接受另一个函数做为最后一个参数，该函数文本参数可以在括号内的参数列表外的传递</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数表达式</p>
<p>指定返回值的函数在大多数情形中是不必要的，因为返回值是可以自动推断的。然而，如果你需要自己指定，可以用函数表达式来做:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span> )</span></span>: <span class="built_in">Int</span> = x + y</span><br><span class="line"><span class="comment">//函数表达式很像普通的函数声明，除了省略了函数名。它的函数体可以是一个表达式(像上面那样)或者是一个块：</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数以及返回值和普通函数是一样的，如果它们可以从上下文推断出参数类型，则参数类型可以省略:</span></span><br><span class="line">ints.filter(<span class="function"><span class="title">fun</span><span class="params">(item)</span></span> = item &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包</p>
<p>一个字面函数或者表达式函数可以访问闭包，即访问自身范围外的声明的变量。不像 java 那样在闭包中的变量是被捕获修改的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">ints.filter&#123;it &gt; <span class="number">0</span>&#125;.forEach &#123;</span><br><span class="line">    sum += it</span><br><span class="line">&#125;</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数表达式扩展</p>
<p>表达式函数的扩展和普通的扩展区别是它有接收类型的规范:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">this</span> + other</span><br><span class="line"><span class="comment">//接收类型必须在表达式函数中明确指定，但字面函数不用。字面函数可以作为扩展函数表达式，但只有接收类型可以通过上下文推断出来,表达式函数的扩展类型是一个带接收者的函数:</span></span><br><span class="line">sum : <span class="built_in">Int</span>.(other: <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="number">1.</span>sum(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>字面函数(lambda)用-&gt;分隔函数体，函数表达式用=分隔函数体。</p>
</li>
<li><p>内联函数</p>
<p>编译器将使用函数的定义体来替代函数调用语句，这种替代行为发生在编译阶段而非程序运行阶段，也就是说把被调用的函数体复制到调用处，好处：</p>
<ul>
<li>减少了方法调用，压栈，出栈的成本。</li>
<li>在kotlin中，函数就是对象，当你调用某个函数的时候，就会创建相关的对象，内存的分配，虚拟调用都有开销，内联可以减少成本。</li>
</ul>
<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">check</span><span class="params">(lock: <span class="type">Lock</span>, body: ()</span></span> -&gt; T): T &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> body()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------调用----------------//</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">     check(l, &#123;<span class="string">"我是lambda方法体"</span>&#125;)<span class="comment">//l是一个Lock对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器会把调用处换成这样：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      l.lock()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我是lambda方法体"</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            l.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如一个函数是inline的，那么参数里的函数，lambda也默认为inline的。如果要部分参数为非inline，可以使用noinline关键字：</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>,<span class="keyword">noinline</span> doOther:(<span class="type">a</span>:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>-&gt;<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非局部返回</p>
<p>Kotlin在lambda中不能直接使用return，要使用return配合标签，但如果内联，则可以在lambda中直接使用return，该return直接作用于调用者函数，也就是说直接作用在调用的地方，谁调用退出谁。其他内联函数中的return一样(return也被复制到了调用内联函数的函数体里)。如果要只退出lambda，可以使用return@xxx。</p>
</li>
<li><p>内联属性</p>
<p>对属性来说，我们会有get，set的方法来操作这个属性。<br>get,set就是个函数，我们可以标识他们为内联函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foo: Foo</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">get</span>() = Foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar: Bar</span><br><span class="line">    <span class="keyword">get</span>() = ...</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">set</span>(v) &#123; ... &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">var</span> bar: Bar</span><br><span class="line">    <span class="keyword">get</span>() = ...</span><br><span class="line">    <span class="keyword">set</span>(v) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化参数类型</p>
<p>有时我们需要访问传递过来的类型，把它作为参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> TreeNode.<span class="title">findParentOfType</span><span class="params">(clazz: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">var</span> p = parent</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; !clazz.isInstance(p)) &#123;</span><br><span class="line">        p = p?.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">myTree.findParentOfType(javaClass&lt;MyTreeNodeType&gt;() )</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">myTree.findParentOfType(MyTreeNodeType::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="comment">//我们想要的仅仅是给这个函数传递一个类型，如果即像下面这样就很方便：</span></span><br><span class="line">myTree.findParentOfType&lt;MyTreeNodeType&gt;()</span><br><span class="line"><span class="comment">//为了达到这个目的，内联函数支持具体化的类型参数申明 reified</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> TreeNode.<span class="title">findParentOfType</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">var</span> p = parent</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p !<span class="keyword">is</span> T) &#123;</span><br><span class="line">        p = p?.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用 refied 修饰符检查类型参数，既然它可以在函数内部访问了，也就基本上接近普通函数了。因为函数是内联的，所以不许要反射，像 !is ｀as｀这样的操作都可以使用。同时，我们也可以像上面那样调用它了 myTree.findParentOfType<mytreenodetype>() 。普通的函数(没有标记为内联的)不能有实例化参数。</mytreenodetype></p>
<p>在很多情况下会使用反射访问类型数据，我们仍然可以使用实例化的类型参数 javaClass() 来访问它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> methodsOf<span class="type">&lt;<span class="keyword">reified</span> T&gt;</span><span class="params">()</span></span> = javaClass&lt;T&gt;().getMethods()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(s: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(methodsOf&lt;String&gt;().joinToString(<span class="string">'\n'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>。。。</p>
<h2 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h2><ul>
<li><p>Kotlin 类型系统致力于消灭空引用(NPE)，在 Kotlin 类型系统中可以为空和不可为空的引用是不同的，属性默认是要赋初值的，不能为空：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: String =<span class="string">"abc"</span></span><br><span class="line">a = <span class="literal">null</span> <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment">//允许为空，我们必须把它声明为可空的变量</span></span><br><span class="line"><span class="keyword">var</span> b: String? = <span class="string">"abc"</span></span><br><span class="line">b = <span class="literal">null</span></span><br><span class="line"><span class="comment">//调用 a 的方法，而不用担心 NPE 异常：</span></span><br><span class="line"><span class="keyword">val</span> l = a.length()</span><br><span class="line"><span class="comment">//使用 b 调用同样的方法就可能报错</span></span><br><span class="line"><span class="keyword">val</span> l = b.length() <span class="comment">//错误：b 可能为空</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用可空属性(?)时的四种方式：</p>
<ul>
<li><p>在条件中检查 null：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length() <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"><span class="comment">//更复杂的条件：</span></span><br><span class="line"><span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; b.length() &gt;<span class="number">0</span>)</span><br><span class="line">  print(<span class="string">"Stirng of length <span class="subst">$&#123;b.length&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  print(<span class="string">"Empty string"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>安全调用,使用安全操作符，?. </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b?.length()</span><br><span class="line"><span class="comment">//如果 b 不为空则返回长度，否则返回空。这个表达式的的类型是 Int?,安全调用在链式调用是是很有用的。比如，如果 Bob 是一个雇员可能分配部门(也可能不分配)，如果我们想获取 Bob 的部门名作为名字的前缀，就可以这样做：</span></span><br><span class="line">bob?.department?.head?.name</span><br><span class="line"><span class="comment">//这样的调用链在任何一个属性为空都会返回空</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Elvis 操作符，?:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b.length()?: <span class="number">-1</span></span><br><span class="line"><span class="comment">//如if表达式：</span></span><br><span class="line"><span class="keyword">val</span> l: <span class="built_in">Int</span> = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length() <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 ?: 左边表达式不为空则返回，否则返回右边的表达式。注意右边的表带式只有在左边表达式为空是才会执行</span></span><br><span class="line"><span class="comment">//注意在 Kotlin 中 throw return 是表达式，所以它们也可以在 Elvis 操作符右边。这是非常有用的，比如检查函数参数是否为空:</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="type">Node</span>)</span></span>: String? &#123;</span><br><span class="line">  <span class="keyword">val</span> parent = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">val</span> name = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"name expected"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>!! 操作符</p>
<p>NPE-lovers，我们可以用 b!! ，这会返回一个非空的 b 或者抛出一个 b 为空的 NPE：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l = b !!.length()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>安全转换</p>
<p>普通的转换可能产生 ClassCastException 异常。另一个选择就是使用安全转换，如果不成功就返回空：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aInt: <span class="built_in">Int</span>? = a <span class="keyword">as</span>? <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h2><ul>
<li><p>在 kotlin 中有两种相等</p>
<ul>
<li><p>参照相等：参照相等是通过 === 操作符判断的(不等是!== ) a===b 只有 a b 指向同一个对象是判别才成立。另外，你可以使用内联函数 identityEquals() 判断参照相等：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.identityEquals(b)</span><br><span class="line">a identityEquals b</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构相等:结构相等是通过 == 判断的。像 a == b 将会翻译成:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a?.equals(b) ?: b === <span class="literal">null</span></span><br><span class="line"><span class="comment">//如果 a 不是 null 则调用 equals(Any?) 函数，否则检查 b 是否参照等于 null</span></span><br><span class="line"><span class="comment">//注意完全没有必要为优化你的代码而将 a == null 写成 a === null 编译器会自动帮你做的</span></span><br></pre></td></tr></table></figure>
<p>kotlin中==相当于java的equals，===相当于java的==</p>
</li>
</ul>
</li>
</ul>
<h2 id="多重申明-解构申明"><a href="#多重申明-解构申明" class="headerlink" title="多重申明(解构申明)"></a>多重申明(解构申明)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (name, age) = person</span><br></pre></td></tr></table></figure>
<ul>
<li><p>意思就是一次性申明多个变量，并把=号右边的对象的属性拆箱出来赋值给变量。如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person: Person = Person(<span class="string">"Jone"</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> (name, age) = person</span><br><span class="line"></span><br><span class="line">println(<span class="string">"name: <span class="variable">$name</span>, age: <span class="variable">$age</span>"</span>)<span class="comment">// 打印：name: Jone, age: 20</span></span><br></pre></td></tr></table></figure>
<p>如果拆箱出对象的属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = person.component1()</span><br><span class="line"><span class="keyword">val</span> age = person.component2()</span><br></pre></td></tr></table></figure>
<p>person.component1，component2怎么来的呢，Kotlin的数据类编译器会根据主构造器中声明的属性, 自动推断生成componentN() 函数群, 这些函数与类的属性对应, 函数名中的数字1到N,与属性的声明顺序一致。那么如果不是数据类就要自己编写对象的componentN函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构申明可以用在for循环中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> personA: Person = Person(<span class="string">"Door"</span>, <span class="number">22</span>, <span class="string">"ShanDong"</span>)</span><br><span class="line"><span class="keyword">var</span> personB: Person = Person(<span class="string">"Green"</span>, <span class="number">30</span>, <span class="string">"BeiJing"</span>)</span><br><span class="line"><span class="keyword">var</span> personC: Person = Person(<span class="string">"Dark"</span>, <span class="number">23</span>, <span class="string">"YunNan"</span>)</span><br><span class="line"><span class="keyword">var</span> personD: Person = Person(<span class="string">"Tool"</span>, <span class="number">26</span>, <span class="string">"GuanDong"</span>)</span><br><span class="line"><span class="keyword">var</span> personE: Person = Person(<span class="string">"Mark"</span>, <span class="number">24</span>, <span class="string">"TianJin"</span>)</span><br><span class="line"><span class="keyword">var</span> pers = listOf(personA, personB, personC, personD, personE)</span><br><span class="line"><span class="keyword">for</span> ((name, age) <span class="keyword">in</span> pers) &#123;</span><br><span class="line">    println(<span class="string">"name: <span class="variable">$name</span>, age: <span class="variable">$age</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map使用结构申明，Kotlin的标准库中，对Map实现了这些扩展函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = entrySet().iterator()</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map.Entry<span class="type">&lt;K, V&gt;</span>.<span class="title">component1</span><span class="params">()</span></span> = getKey()</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map.Entry<span class="type">&lt;K, V&gt;</span>.<span class="title">component2</span><span class="params">()</span></span> = getValue()</span><br></pre></td></tr></table></figure>
<p> 所以在使用Map.Entry.getkey时使用调用到component1()，getvalue时调用component2()：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> personA: Person = Person(<span class="string">"Door"</span>, <span class="number">22</span>, <span class="string">"ShanDong"</span>)</span><br><span class="line">    <span class="keyword">var</span> personB: Person = Person(<span class="string">"Green"</span>, <span class="number">30</span>, <span class="string">"BeiJing"</span>)</span><br><span class="line">    <span class="keyword">var</span> personC: Person = Person(<span class="string">"Dark"</span>, <span class="number">23</span>, <span class="string">"YunNan"</span>)</span><br><span class="line">    <span class="keyword">var</span> personD: Person = Person(<span class="string">"Tool"</span>, <span class="number">26</span>, <span class="string">"GuanDong"</span>)</span><br><span class="line">    <span class="keyword">var</span> personE: Person = Person(<span class="string">"Mark"</span>, <span class="number">24</span>, <span class="string">"TianJin"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> map = HashMap&lt;String, Person&gt;()</span><br><span class="line">    map.put(<span class="string">"1"</span>, personA)</span><br><span class="line">    map.put(<span class="string">"2"</span>, personB)</span><br><span class="line">    map.put(<span class="string">"3"</span>, personC)</span><br><span class="line">    map.put(<span class="string">"4"</span>, personD)</span><br><span class="line">    map.put(<span class="string">"5"</span>, personE)</span><br><span class="line">    <span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123;</span><br><span class="line">        println(<span class="string">"key: <span class="variable">$key</span>, value: <span class="variable">$value</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Log打印</span></span><br><span class="line">key: <span class="number">1</span>, value: Person(name=<span class="string">'Door'</span>, age=<span class="number">22</span>, addr=<span class="string">'ShanDong'</span>, mobile=<span class="literal">null</span>)</span><br><span class="line">key: <span class="number">2</span>, value: Person(name=<span class="string">'Green'</span>, age=<span class="number">30</span>, addr=<span class="string">'BeiJing'</span>, mobile=<span class="literal">null</span>)</span><br><span class="line">key: <span class="number">3</span>, value: Person(name=<span class="string">'Dark'</span>, age=<span class="number">23</span>, addr=<span class="string">'YunNan'</span>, mobile=<span class="literal">null</span>)</span><br><span class="line">key: <span class="number">4</span>, value: Person(name=<span class="string">'Tool'</span>, age=<span class="number">26</span>, addr=<span class="string">'GuanDong'</span>, mobile=<span class="literal">null</span>)</span><br><span class="line">key: <span class="number">5</span>, value: Person(name=<span class="string">'Mark'</span>, age=<span class="number">24</span>, addr=<span class="string">'TianJin'</span>, mobile=<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h2><ul>
<li><p>表示从多少到多少，可用于if判断和for循环，与in关键字配合，常见用法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Checking if value of comparable is in range. Optimized for number primitives.</span></span><br><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) println(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x !<span class="keyword">in</span> <span class="number">1.0</span>.<span class="number">.3</span><span class="number">.0</span>) println(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str <span class="keyword">in</span> <span class="string">"island"</span>..<span class="string">"isle"</span>) println(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterating over arithmetical progression of numbers. Optimized for number primitives (as indexed for-loop in Java).</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) print(i) <span class="comment">// prints "1234"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4.</span><span class="number">.1</span>) print(i) <span class="comment">// prints nothing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span>) print(i) <span class="comment">// prints "4321"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "13"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">1.</span><span class="number">.4</span>).reversed()) print(i) <span class="comment">// prints "4321"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">1.</span><span class="number">.4</span>).reversed() step <span class="number">2</span>) print(i) <span class="comment">// prints "42"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// prints "42"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.0</span>.<span class="number">.2</span><span class="number">.0</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "1.0 2.0 "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.0</span>.<span class="number">.2</span><span class="number">.0</span> step <span class="number">0.3</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "1.0 1.3 1.6 1.9 "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">2.0</span> downTo <span class="number">1.0</span> step <span class="number">0.3</span>) print(<span class="string">"<span class="variable">$x</span> "</span>) <span class="comment">// prints "2.0 1.7 1.4 1.1 "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (str <span class="keyword">in</span> <span class="string">"island"</span>..<span class="string">"isle"</span>) println(str) <span class="comment">// error: string range cannot be iterated over</span></span><br></pre></td></tr></table></figure>
<p>原理参见标准库中接口：Range ，Progressiont和和操作函数的扩展。</p>
</li>
<li><p>for in :</p>
<p>如果你想通过 list 或者 array 的索引进行迭代，你可以这样做：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices)</span><br><span class="line">    print(array[i])</span><br><span class="line"><span class="comment">//-------------------------//</span></span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h2><ul>
<li><p>类型检查:is !is 表达式:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时检查一个对象是否是某个特定类：</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    print(obj.length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj !<span class="keyword">is</span> String) &#123; <span class="comment">// same as !(obj is String)</span></span><br><span class="line">    print(<span class="string">"Not a String"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    print(obj.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//智能转换,编译器会跟踪 is 检查静态变量，并在需要的时候自动插入安全转换:</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">is</span> String) &#123;</span><br><span class="line">        print(x.length) <span class="comment">// x is automatically cast to String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x !<span class="keyword">is</span> String) <span class="keyword">return</span></span><br><span class="line">print(x.length) <span class="comment">//x 自动转换为 String</span></span><br><span class="line"><span class="comment">//在 || &amp;&amp; 操作符，when 表达式和 whie 循环中：</span></span><br><span class="line"> <span class="comment">// x is automatically cast to string on the right-hand side of `||`</span></span><br><span class="line">  <span class="keyword">if</span> (x !<span class="keyword">is</span> String || x.length == <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// x is automatically cast to string on the right-hand side of `&amp;&amp;`</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">is</span> String &amp;&amp; x.length &gt; <span class="number">0</span>)</span><br><span class="line">      print(x.length) <span class="comment">// x is automatically cast to String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; print(x + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">is</span> String -&gt; print(x.length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">is</span> Array&lt;<span class="built_in">Int</span>&gt; -&gt; print(x.sum())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换：</p>
<p>用as 操作符来转换类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: String = y <span class="keyword">as</span> String</span><br><span class="line"><span class="comment">//null 不能被转换为 String 因为String不是 nullable，也就是说如果 y 是空的，则上面的代码会抛出空异常。为了 java 的转换语句匹配我们得像下面这样：</span></span><br><span class="line"><span class="keyword">val</span> x: String?= y <span class="keyword">as</span> String?</span><br></pre></td></tr></table></figure>
<p>“安全”转换：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: String ?= y <span class="keyword">as</span>? String</span><br><span class="line"><span class="comment">//为了避免抛出异常，可以用 as? 这个安全转换符，这样失败就会返回 null</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="This表达式"><a href="#This表达式" class="headerlink" title="This表达式"></a>This表达式</h2><ul>
<li><p>如果 this 没有应用者，则指向的是最内层的闭合范围。为了在其它范围中返回 this ，需要使用标签:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this@lable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// implicit label @A</span></span><br><span class="line">  inner <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; <span class="comment">// implicit label @B</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">foo</span><span class="params">()</span></span> &#123; <span class="comment">// implicit label @foo</span></span><br><span class="line">      <span class="keyword">val</span> a = <span class="keyword">this</span><span class="symbol">@A</span> <span class="comment">// A's this</span></span><br><span class="line">      <span class="keyword">val</span> b = <span class="keyword">this</span><span class="symbol">@B</span> <span class="comment">// B's this</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> c = <span class="keyword">this</span> <span class="comment">// foo()'s receiver, an Int</span></span><br><span class="line">      <span class="keyword">val</span> c1 = <span class="keyword">this</span><span class="symbol">@foo</span> <span class="comment">// foo()'s receiver, an Int</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> funLit = <span class="meta">@lambda</span> &#123;String.() -&gt;</span><br><span class="line">        <span class="keyword">val</span> d = <span class="keyword">this</span> <span class="comment">// funLit's receiver</span></span><br><span class="line">        <span class="keyword">val</span> d1 = <span class="keyword">this</span><span class="symbol">@lambda</span> <span class="comment">// funLit's receiver</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> funLit2 = &#123; (s: String) -&gt;</span><br><span class="line">        <span class="comment">// foo()'s receiver, since enclosing function literal </span></span><br><span class="line">        <span class="comment">// doesn't have any receiver</span></span><br><span class="line">        <span class="keyword">val</span> d1 = <span class="keyword">this</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="运算符号重载"><a href="#运算符号重载" class="headerlink" title="运算符号重载"></a>运算符号重载</h2><p>。。。</p>
<p> operator fun get(position: Int) = dailyForecast[position]</p>
<p>//xxx[position]</p>
<h2 id="一些使用时的笔记-建议"><a href="#一些使用时的笔记-建议" class="headerlink" title="一些使用时的笔记(建议)"></a>一些使用时的笔记(建议)</h2><ul>
<li><p>当需要把一个对象转成另一个，或有多个当前类或对象的.调用等，可以使用这些扩展和函数，提高效率：</p>
<ul>
<li>let</li>
<li>apply</li>
<li>run</li>
<li>with，with是个函数</li>
</ul>
</li>
<li><p>使用.isNullOrEmpty(),isNullOrBlank(),isBlank(),isEmpty(),isNotBlank(),isNotEmpty()来代替TextUtils判断字符串。</p>
</li>
<li><p>善用集合中的各种扩展函数，如reduce,filter,map,any,all,count,max,sumBy等等。</p>
</li>
<li><p>构造函数里的变量如果要在类中使用(类属性)要标记定义关键字var或val，否则作用域不会是整个类，就像只是函数的参数一样。</p>
</li>
<li><p>一些高阶函数，lambda {}里不要用return，是返回的最后一行，如果用return他又是inline的话会返回了外层的函数。</p>
</li>
<li><p>利用默认参数减少(java)方法重载</p>
</li>
<li><p>可空也是一种类型(可空的xx类型)，可接受实参为空或具体类型的实例，可空类型的实例变量要解包(!!)后才可以使用原类型的属性、方法。</p>
</li>
<li><p>for( index in 5..1),其中5和1只能是数值，如果用变量要用(x-1)包起来并转成数字:for (i in (x+1)..(y+1))。</p>
</li>
<li><p>kotlin 没有Volatile等并发编程的关键字，这是kotlin有意为之，kotlin让为这应该让函数库来做，但并不是不能用，可以使用@Volatile，@Synchronized注解来使用相应功能，@Volatile标记jvm的备用字段为volatile。wait(), notify()等Object(在Kotlin的Any中没有这些方法)的方法可以这么使用:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> lock = java.lang.Object()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> = synchronized(lock) &#123;  </span><br><span class="line">  <span class="keyword">while</span> (items &gt;= maxItems) &#123;</span><br><span class="line">    lock.wait()</span><br><span class="line">  &#125;</span><br><span class="line">  Thread.sleep(rand.nextInt(<span class="number">100</span>).toLong())</span><br><span class="line">  items++</span><br><span class="line">  println(<span class="string">"Produced, count is <span class="variable">$items</span>: <span class="subst">$&#123;Thread.currentThread()&#125;</span>"</span>)</span><br><span class="line">  lock.notifyAll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">()</span></span> = synchronized(lock) &#123;  </span><br><span class="line">  <span class="keyword">while</span> (items &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    lock.wait()</span><br><span class="line">  &#125;</span><br><span class="line">  Thread.sleep(rand.nextInt(<span class="number">100</span>).toLong())</span><br><span class="line">  items--</span><br><span class="line">  println(<span class="string">"Consumed, count is <span class="variable">$items</span>: <span class="subst">$&#123;Thread.currentThread()&#125;</span>"</span>)</span><br><span class="line">  lock.notifyAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当碰到用java时常用的如果不如为就…时可以用let等扩展:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">data</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">   nameTv.setText(<span class="keyword">data</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">data</span>?.apply &#123;</span><br><span class="line">    nameTv.text=name</span><br><span class="line">    info&#123;<span class="string">"xxx"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">data</span>?.let&#123;</span><br><span class="line">    nameTv.text=it.name</span><br><span class="line">&#125;</span><br><span class="line">mOnActionListener?.onAction()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用高阶函数+函数对象定义监听器(java中的onClickListener等)</p>
</li>
<li><p>当可变属性(var)定义为可空(?)时编译器报错：Smart cast to ‘Type’ is impossible, because ‘variable’ is a mutable property that could have been changed by this time 解决的几种办法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> names: ArrayList&lt;String&gt; = ArrayList()</span><br><span class="line"><span class="comment">//1:如果能用只读，改成val。</span></span><br><span class="line"><span class="comment">//2:：用一个本地变量接收再使用：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> nameLoc = a.name</span><br><span class="line">  <span class="keyword">if</span>(nameLoc != <span class="literal">null</span>) &#123;</span><br><span class="line">     names.add(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3：用？操作符</span></span><br><span class="line">name?.let&#123;</span><br><span class="line">     names.add(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4：如果是在用Elvis操作符</span></span><br><span class="line">foo1(name?:<span class="string">""</span>)</span><br><span class="line"><span class="comment">//循环中</span></span><br><span class="line"> names.add(name?:<span class="keyword">continue</span>);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
 
            <div>    
 
    <ul class="post-copyright">
      <li class="post-copyright-author">
          <strong>本文作者：</strong>HomgWu
      </li>
      <li class="post-copyright-link">
        <strong>本文链接：</strong>
        <a href="http://zhuchen.vip/2018/04/01/kotlin/kotlin-learn-summary.html" title="Kotlin知识点总结与初写时的一些建议">http://zhuchen.vip/2018/04/01/kotlin/kotlin-learn-summary.html</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明： </strong>
        本博客所有文章除特别声明外，均属原创，版权所有 © 如需转载请注明出处！
      </li>
    </ul>
  
</div>

      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/02/android/android-slide_select_recyclerview.html" rel="next" title="一个滑动选中RecyclerView中Item的布局SlidingCheckLayout，手指滑过Item时多项选中。">
                <i class="fa fa-chevron-left"></i> 一个滑动选中RecyclerView中Item的布局SlidingCheckLayout，手指滑过Item时多项选中。
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/04/android/android-viewpager-adapter-update-move-add.html" rel="prev" title="Viewpager+FragmentStatePagerAdapter动态添加，删除，移动位置，(局部)更新页面(Fragment)不闪屏，不错位解决方案">
                Viewpager+FragmentStatePagerAdapter动态添加，删除，移动位置，(局部)更新页面(Fragment)不闪屏，不错位解决方案 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNTU5NS8xMjEzMQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="HomgWu" />
            
              <p class="site-author-name" itemprop="name">HomgWu</p>
              <p class="site-description motion-element" itemprop="description">道心之中有衣食，衣食之中无道心</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/5f143ed9dd11" target="_blank" title="简书"><i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/595e03895188250d87650d56" target="_blank" title="掘金"><i class="fa fa-fw fa-spinner"></i>掘金</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象相关"><span class="nav-number">1.</span> <span class="nav-text">对象相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性字段相关"><span class="nav-number">2.</span> <span class="nav-text">属性字段相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译时常量"><span class="nav-number">3.</span> <span class="nav-text">编译时常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟初始化属性"><span class="nav-number">4.</span> <span class="nav-text">延迟初始化属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复写属性"><span class="nav-number">5.</span> <span class="nav-text">复写属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理-委托-模式"><span class="nav-number">6.</span> <span class="nav-text">代理(委托)模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#密封类"><span class="nav-number">7.</span> <span class="nav-text">密封类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">8.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展"><span class="nav-number">9.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性扩展"><span class="nav-number">9.1.</span> <span class="nav-text">属性扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伴随对象扩展"><span class="nav-number">9.2.</span> <span class="nav-text">伴随对象扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类"><span class="nav-number">10.</span> <span class="nav-text">数据类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">11.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套类"><span class="nav-number">12.</span> <span class="nav-text">嵌套类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">13.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程"><span class="nav-number">14.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空安全"><span class="nav-number">15.</span> <span class="nav-text">空安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等式"><span class="nav-number">16.</span> <span class="nav-text">等式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重申明-解构申明"><span class="nav-number">17.</span> <span class="nav-text">多重申明(解构申明)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ranges"><span class="nav-number">18.</span> <span class="nav-text">Ranges</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型检查和转换"><span class="nav-number">19.</span> <span class="nav-text">类型检查和转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#This表达式"><span class="nav-number">20.</span> <span class="nav-text">This表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符号重载"><span class="nav-number">21.</span> <span class="nav-text">运算符号重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些使用时的笔记-建议"><span class="nav-number">22.</span> <span class="nav-text">一些使用时的笔记(建议)</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HomgWu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">85k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点总阅读时长">1:25</span>
  
</div>


<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io" rel="external nofollow">Hexo</a> 强力驱动 v3.7.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next" rel="external nofollow">NexT.Pisces</a> v6.1.0</div>

-->


        








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1273386415&web_id=1273386415" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  



	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("WrMYkpcA8xY3lVbQet9yGyY4-gzGzoHsz", "zEpnonqPyRoWG4VuS1o7qzPs");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var newcounter = new Counter();
              /* Set ACL */
              var acl = new AV.ACL();
              acl.setPublicReadAccess(true);
              acl.setPublicWriteAccess(true);
              newcounter.setACL(acl);
              /* End Set ACL */
              newcounter.set("title", title);
              newcounter.set("url", url);
              newcounter.set("time", 1);
              newcounter.save(null, {
                success: function(newcounter) {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                },
                error: function(newcounter, error) {
                  console.log('Failed to create');
                }
              });
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  
  

  

  

  

  

</body>
</html>
